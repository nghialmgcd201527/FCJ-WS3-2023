[
{
	"uri": "/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Before going into the labs, this section will introduce the basic knowledge that needs to be learned and understood in this workshop.\n"
},
{
	"uri": "/3-cache/3.1-urired/",
	"title": "URI based Redirects",
	"tags": [],
	"description": "",
	"content": "In this section, we will start with a simple case that can be easily understood using Lambda@Edge as this case can be cached, so it is best handled with the Lambda@Edge.\nThis case is often used to redirect users for some reason when requesting a URI that the admin does not want that user to see or the URI may no longer be available. For example, a user can send requests to /uri-main.html, however, the admin wants all those requests to be made by /uri-redirect.html\nStep 1: Create Cache Behavior for this case To make this happen, you will first create a specific cache behavior. The following steps will guide you to do this.\nGo to CloudFront console. You will see the Distribution created by the CloudFormation template, it will be determined by the Edge Redirect Workshop Distribution as in the Description section. Select that Distribution then select Behaviors. Click on the Create Behavior button. In the Path pattern section, we enter /uri-main.html, below is the Origin and origin groups section, we select myS3Origin. In the Viewer protocol policy section , we choose Redirect HTTP to HTTPS. We will leave the remaining items as default and click on the Create behavior button at the bottom of the page. Step 2: Create Lambda@Edge function and publish new version This step will be the process of creating our function along with its version. Lambda@Edge functions need to be referred to by CloudFront Distribution based on their ARN version, not their main function ARN.\nGo into Lambda Console in AWS Region us-east-1, click on the Create function. button On the Create function page, name our function edge-uri-redirect, select Python 3.9 for the Runtime section. At the bottom, we open the section Change default execution role then select Use an existing role, we select edge-redirect-lambda-role (this is a role created from CloudFormation template). Finally, click on the Create function. button Once the function is created, we are on the main page of that function. In the Code section below, we copy the code below and paste it into the Code source section. import json\rdef lambda_handler(event, context):\rget_uri = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;uri\u0026#39;]\rprint(get_uri)\rif (get_uri == \u0026#39;/uri-main.html\u0026#39;):\rresponse = {\r\u0026#39;status\u0026#39;: \u0026#39;301\u0026#39;,\r\u0026#39;statusDescription\u0026#39;: \u0026#39;Permanent Redirect\u0026#39;,\r\u0026#39;headers\u0026#39;: {\r\u0026#39;location\u0026#39;: [{\r\u0026#39;key\u0026#39;: \u0026#39;Location\u0026#39;,\r\u0026#39;value\u0026#39;: \u0026#39;/uri-redirect.html\u0026#39;\r}]\r}\r}\rreturn response\relse:\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request In this code, it is used as an AWS CloudFront function. It serves the CloudFront event handler and implements logic for URL redirection based on the requested URI. Function lambda_handler is the entry point of Lambda function, it includes 2 parameters event and context. This function extracts the URI requested from the CloudFront event. If the request URI is /uri-main.html, the code will return a response with status code 301 and location header set to /uri-redirect.html. If the URI is not /uri-main.html, the code will return the request object.\nNext, click on the Deploy button to commit the code of our lambda function. When our code is successfully deployed, we will publish a new version of this lambda. Click on the Actions button in the right corner, we choose Publish new version. We enter edge-uri-redirect-v1 for the Version description and click on the Publish button.\nStep 3: Combine Lambda Function with CloudFront Behavior Return to the lambda function console and open function edge-uri-redirect.\nClick + Add trigger\nOn the Trigger configuration page, we select CloudFront for the source section. Then click Deploy on Lambda@Edge. A new window opens, in the Distribution section, we select the distribution created from the CloudFormation template. For Cache behavior, we choose /uri-main.html. In the CloudFront event section, select Origin request. Check the Confirm deploy to Lambda@Edge box and click on the Deploy button. Step 4: Set up client for testing To test specific redirects, we will need a client to run curl commands. The easy way is to create CloudShell Environments. CloudShell is a shell available in the AWS console and we can run Linux commands from it. Go to CloudShell Console and wait until the terminal is ready to use.\nIf CloudShell does not work, if you are doing this workshop on a Linux/MacOS client, these two operating systems already have curl and you just need to run the command on that client. If you are using Windows, use online curl tools like this one. You can run an EC2 instance or Cloud9 IDE from AWS COnsole to run commands.\nStep 5: Test redirect configuration Forward to CloudShell Console.\nIn the test, we will run the curl command to send http requests to our distrubtion, to do so, we need to copy the Distribution domain name from the CloudFront console where we can find it.\nOnce you\u0026rsquo;ve found the distribution domain name, copy the following command and replace it with our domain name.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/uri-main.html After building the above command from cloudshell, we will see the result as below. We can see in the above result, this request receives an HTTP 301 response, indicating redirect, and the Location header is the URI where the client is redirected to.\nNow, let\u0026rsquo;s run the same command again. And see the difference. The difference when running this command is the value of the X-Cache header. The request now receives a redirected and cached response from the previous command run. This means that our Lambda@edge does not need to be triggered again, saving time and costs.\nWe have successfully deployed the first redirect using Lambda@Edge and have finished testing. Now we move to the next case.\n"
},
{
	"uri": "/1-introduce/1.1-usecase/",
	"title": "Use Cases",
	"tags": [],
	"description": "",
	"content": "In this section, we\u0026rsquo;ll learn the basics about the Edge Compute features we\u0026rsquo;ll explore in this workshop. It will provide us with background knowledge and content related to labs.\nBefore introducing AWS Edge computes, we need to have some knowledge about the different techniques used in this workshop to redirect pages from one page to another. different from user requirements. It\u0026rsquo;s called Redirects and Rewrites.\nRedirects: URL redirections take the browser to a new resource or another website. Common HTTP response codes are HTTP 301, HTTP 302 and HTTP 308. After the browser receives the response from the server, it will fetch content from the URL returned by the server. For more information, see here. There are some use cases where customers want Redirects including situations where they need to route users to a new domain or even when redirecting users to the main website, redirecting to send users to a page based on device or geographical location. theirs and other cases that we will learn about in this workshop.\nRewrites: URL rewrites are also a technique used to store a different content than what the user requested, however it will not handle a full redirect. Instead, it will just serve another content from the backend of the website or application without the user knowing what is going on. For example, we can think of the browser sending a GET request to fetch content for \u0026ldquo;/index.html\u0026rdquo;, but we can modify the URL according to this request and make the backend return content from \u0026ldquo;/index_rewrite.html\u0026rdquo;. This will essentially provide different content than the original request without the server sending the user to a completely different URL/page. Some use cases of URL rewrite are cases where it is necessary to rearrange characters from the URL, in this case, it will retrieve the content and not change the URL which is very important so that the user experience can be simple. simpler and other cases that we will learn about in this workshop.\n"
},
{
	"uri": "/",
	"title": "Using Edge Functions to handle Rewrites and Redirects",
	"tags": [],
	"description": "",
	"content": "Using Edge Functions to handle Rewrites and Redirects Overview In this workshop, we will learn how to handle common redirect and rewrite scenarios using Edge Compute features provided by AWS.\nThe main goal of this is to provide viewers with knowledge on how to use Edge Compute features to apply redirects to their applications and understand how to use those features most effectively.\nThis workshop is where you will perform labs using the Compute platforms available in CloudFront to access different redirects and rewrites. Here we will use Lambda@Edge because the responses from these instances are cacheable responses.\nPrerequisites To complete this workshop, we need knowledge of CDNs and basic JavaScript/Python programming knowledge to understand the code and knowledge throughout the workshop.\nNá»™i dung Introduction Solution Deployment Use case of Cacheable Cleanup "
},
{
	"uri": "/1-introduce/1.2-edge/",
	"title": "Edge Compute",
	"tags": [],
	"description": "",
	"content": "Before starting the lab, we should have a basic understanding of the type of edge compute capabilities we will use in this lab, currently available in CloudFront.\nCloudFront Edge Compute Features Lambda@Edge: This is a feature of Amazon CloudFront allows you to run code closer to the users of your application, improving performance and reducing latency. With Lambda@Edge, we don\u0026rsquo;t have to provision or manage infrastructure in multiple locations around the world. We only pay for the compute time we use and not when our code is not in use. With Lambda@Edge, we can enrich our web applications by distributing them globally and improving their performance - all without the need for server administration. Lambda@Edge runs our code in response to events generated by the Amazon CloudFront content delivery network. Simply upload our code to AWS Lambda, which will handle everything needed to run and scale our code with high availability at an AWS location closest to our end user.\nCloudFront Edge Compute Triggers Amazon CloudFront requires four different event types for custom requests and responses to be exchanged between the viewer and the server (origin).\nViewer Request - This function executes when CloudFront receives a request from the viewer and before it checks whether the requested object is in the edge cache or not.\nOrigin Request - This function only executes when CloudFront forwards the request to our origin. When the request object is in the edge cache, the function is not executed.\nOrigin Response - This function executes after CloudFront receives the response from the origin and before it caches the object in the response.\nViewer Response - Function executes before returning the requested object to the viewer. The function executes regardless of whether the object is in the edge cache or not.\nAll the above 4 trigger options are available with Lambda@Edge while only viewer triggers are available with CloudFront Functions. This is one of the most important and important differences between the above two features and we will explore more about the Lambda@Edge feature throughout the workshop.\nCloudFront Edge Locations vÃ  Regional Edge Caches (RECs) CloudFront Edge Locations are points of presence where user requests will be sent based on latency lowest for the user sending that request. The content of CloudFront Delivers is detected by which Edge Locations can serve requests and route users to the identified Edge Locations.\nRegional Edge Cache is the middle tier caching layer between Edge Location and Origin. Regional Edge Cache servers are used to allow more content to be cached closer to the user.\nThe following diagram shows how the Edge Locations and Regional Edge Cache groups are used by CloudFront:\n"
},
{
	"uri": "/3-cache/3.2-geored/",
	"title": "Geo Location Redirects",
	"tags": [],
	"description": "",
	"content": "This case is often used to redirect the viewer to the country page of our website. In the diagram below, we can see the structure built for this part.\nStep 1: Create CloudFront Cache policy to forward country header: To be able to Redirect users based on country location. We need to make sure that the Contry Header binds to the Lambda@Edge function. To do this, we need to create a Cache Policy where headers are added to the cache key.\nGo to the CloudFront Cache Policies console.\nIn the Custom Policies section, click on the Create cache policy button.\nOn the Create cache policy page, name it edge-redirect-cache-policy. In the Cache key settings section, expand the Headers section and select Include the following headers. In the Add header section, we search for CloudFront-Viewer-Country and select it. Leave the other items as default and click the Create button. Step 2: Create Lambda@Edge function and publish new version In this step, we will do as in the previous part, create a Lambda function with the name edge-geo-redirect, Runtime is Python 3.9 and deploy it. After that, we need to publish the new version of the Lambda function we just created.\nCode source cá»§a Lambda function nÃ y lÃ :\nimport json\rdef lambda_handler(event, context):\r#Let\u0026#39;s first get the Country Code from the Request coming in\rget_country_viewer_header = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;headers\u0026#39;][\u0026#39;cloudfront-viewer-country\u0026#39;]\rdefine_country = get_country_viewer_header[0][\u0026#39;value\u0026#39;]\r#Now let\u0026#39;s define which country that is and create our redirected response\rif (define_country == \u0026#39;US\u0026#39;):\rresponse = {\r\u0026#39;status\u0026#39;: \u0026#39;301\u0026#39;,\r\u0026#39;statusDescription\u0026#39;: \u0026#39;Permanent Redirect\u0026#39;,\r\u0026#39;headers\u0026#39;: {\r\u0026#39;location\u0026#39;: [{\r\u0026#39;key\u0026#39;: \u0026#39;Location\u0026#39;,\r\u0026#39;value\u0026#39;: \u0026#39;/en-us.html\u0026#39;\r}]\r}\r}\r#The response above has been created and a response will be sent to the viewer to redirect it to the /en-us.html\rreturn response\relse:\r#if the country has not been identified then move on with the request\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Step 3: Create CloudFront behavior for this case Now the Lambda function has just been created and we have to assign it to a Cache Behavior in CloudFront.\nGo to CloudFront console. You will see the Distribution created by the CloudFormation template, it will be determined by the Edge Redirect Workshop Distribution as in the Description section.\nSelect that Distribution then select Behaviors.\nClick on the Create Behavior button.\nIn the Path pattern section, we enter /geo.html. Below is the Origin and origin groups section, we choose myS3Origin. In the Viewer protocol policy section, we choose Redirect HTTP to HTTPS. In the Cache key section and origin requests, we select Cache policy and origin request policy, next expand the section Cache policy, we select the policy we just created in the previous step edge-redirect-cache-policy . We will leave the remaining items as default and click on the Create behavior button at the bottom of the page.\nStep 4: Combine Lambda Function with CloudFront Behavior We do the same as in the URI based Redirects case above, we will combine the Lambda function edge-geo-redirect with the CloudFront Behavior we just created above.\nStep 5: Set up clients for testing We will need a client to run curl commands. The easy way is to create CloudShell Environments. CloudShell is a shell available in the AWS console and we can run Linux commands from it. Go to CloudShell Console and wait until the terminal is ready to use.\nIf CloudShell does not work, if you are doing this workshop on a Linux/MacOS client, these two operating systems already have curl and you just need to run the command on that client. If you are using Windows, use online curl tools like this one. You can run an EC2 instance or Cloud9 IDE from AWS COnsole to run commands.\nStep 6: Test redirect configuration Go to CloudShell Console in AWS Region **us-east-1 **.\nIn the test, we will run the curl command to send http requests against our distribution, to do so, we need to copy the Distribution domain name from the CloudFront console where we can find it.\nOnce you\u0026rsquo;ve found the distribution domain name, copy the following command and replace it with our domain name.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/geo.html After building the above command from cloudshell, we will see the result as below. \u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /en-us.html\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 6fbeae74487f866b555dc44d03fcc2a6.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: MIA3-P3\r\u0026lt; X-Amz-Cf-Id: VRNhLpCaNiZ08Fw5f2eMtWn8KfHnkPp3qp4kQeft3CVfEjo6kXIEWQ== Let\u0026rsquo;s run the above command again in AWS Region us-east-1. We will see different responses. \u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /en-us.html\r\u0026lt; X-Cache: Hit from cloudfront\r\u0026lt; Via: 1.1 e759cef9ef04dc6632a71818dfac3a76.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: MIA3-P3\r\u0026lt; X-Amz-Cf-Id: aOe3ADve7yDyHH_Iyb7MGMPAX8LWuTli79qf-nFl8rT40-VxPb_Zeg==\r\u0026lt; Age: 158 The only difference here is the X-Cache response header. We will see Hit from cloudfront because in the first response after the request, it has been cached in CloudFront so the second request will not need to go through all the functions instead it will only be fired from cached. content, this provides better performance and also saves costs because the function does not need to be triggered again.\nNow, go back to the shell console and run the same command above in AWS Region eu-west-1. Now our response will not be HTTP 301 but HTTP 200 OK as shown below. \u0026lt; HTTP/1.1 200 OK\r\u0026lt; Content-Type: text/html\r\u0026lt; Content-Length: 98\r\u0026lt; Connection: keep-alive\r\u0026lt; ETag: \u0026#34;be3c901839ae019e0c58908e45f5ab45\u0026#34;\r\u0026lt; Accept-Ranges: bytes\r\u0026lt; Server: AmazonS3\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 9bbdfc2323989883f386114cc53fdbd0.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: MIA3-P3\r\u0026lt; X-Amz-Cf-Id: 2UlANwUbwF5Mv1V-XKWcYWKrTzIJZh2asxxw_xOK7aahkVP6TS6tRg==\r\u0026lt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;Not our US page\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;Not our US page\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; This request\u0026rsquo;s HTTP 200 OK response means it was not redirected and instead, the requested resource was provided by CloudFront.\nSo we have successfully deployed redirect logic using Lambda@Edge and finished testing. This case can be expanded to be more complex, determining not only Contry but also other geographic locations such as States, Cities, postal codes, time zones. Refer to this document to learn more about all headers location is possible in CloudFront.\n"
},
{
	"uri": "/2-prerequiste/",
	"title": "Solution Deployment",
	"tags": [],
	"description": "",
	"content": "This method will create services to serve this workshop. These services will be created using AWS CloudFormation. AWS CloudFormation is an AWS service that helps us automate the deployment of AWS resources. We will use AWS CloudFormation to create CloudFront distribution, Amazon S3 Bucket and IAM Role.\nLet\u0026rsquo;s deploy this template as follows:\nLaunch this CloudFormation template. On this page, scroll down to the Capabilities section, check the box \u0026ldquo;I acknowledge that AWS CloudFormation might create IAM resources with custom names.\u0026rdquo; and click the Create stack button as shown below It will take a few minutes for this stack to be created successfully. You will see something similar to the image below. Next, download the html file (which will serve our Origin). Download here. Store it on your device and extract it. This file will contain the html file that we will use for the Origin content. Now let\u0026rsquo;s move to the S3 bucket page. We will see the S3 bucket created by our CloudFormation template. Click on that S3 bucket, click on the Upload button. Click on the Add files button, select the html file downloaded above and upload that file to our S3 bucket. So we have just finished installing the environment. Now we can start practicing with our workshop.\nWe can deploy our resource another way which is CDK Project. We will use [CloudShell](https://us-east-1.console.aws.amazon.com/cloudshell/home ?region=us-east-1) in AWS Region us-east-1. Download the CDK project file in zip format at this link. And read the support documentation for deploy CDK project here.\nLet\u0026rsquo;s review all deployed resources to better understand our workshop. Then let\u0026rsquo;s start practicing.\n"
},
{
	"uri": "/3-cache/3.3-devicered/",
	"title": "Device Redirects",
	"tags": [],
	"description": "",
	"content": "This case is used to redirect the viewer to the website\u0026rsquo;s proper page based on the type of device sending the request. The following diagram shows the architecture and requested steps that we will do in this section.\nStep 1: Create CloudFront Cache policy to forward device type header: To be able to Redirect users based on device type, CloudFront headers determine the device type of the user that will be linked to the Lambda@Edge function. To do that, you will need to create a Cache Policy in which a header is added to the cache key. In this workshop, you will use CloudFront-Is-Mobile-Viewer but other headers are also available.\nGo to the [CloudFront Policies console] page(https://us-east-1.console.aws.amazon.com/cloudfront/v3/home?region=us-east-1#/policies/cache). We do the same as the Geo Location Redirects section above, we create a Cache Policy named device-redirect-cache-policy. And in Headers of the Cache key settings section, we search and select CloudFront-Is-Mobile-Viewer. Finally, we click on the Create button.\nStep 2: Create Lambda@Edge function and publish new version In this step, we will do as in the previous section, create a Lambda function with the name edge-device-redirect, Runtime is Python 3.9 and deploy it. After that, we need to publish the new version of the Lambda function we just created.\nThe source code of this Lambda function is:\nimport json\rdef lambda_handler(event, context):\rprint(event)\r#Let\u0026#39;s first get the Device Type from the Request coming in\rget_device_viewer_header = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;headers\u0026#39;][\u0026#39;cloudfront-is-mobile-viewer\u0026#39;]\rdefine_device_type = get_device_viewer_header[0][\u0026#39;value\u0026#39;]\rprint(define_device_type)\r#Now let\u0026#39;s see if this device is a mobile viewer or not and create the redirected response based on that\rif (define_device_type == \u0026#39;true\u0026#39;):\rresponse = {\r\u0026#39;status\u0026#39;: \u0026#39;301\u0026#39;,\r\u0026#39;statusDescription\u0026#39;: \u0026#39;Permanent Redirect\u0026#39;,\r\u0026#39;headers\u0026#39;: {\r\u0026#39;location\u0026#39;: [{\r\u0026#39;key\u0026#39;: \u0026#39;Location\u0026#39;,\r\u0026#39;value\u0026#39;: \u0026#39;/mobile.html\u0026#39;\r}]\r}\r}\r#The response above has been created and a response will be sent to the viewer to redirect it the right device page\rreturn response\relse:\r#if the device is not mobile, then move along with the request as is.\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Step 3: Create CloudFront behavior for this case Now the Lambda function has just been created and we have to assign it to a Cache Behavior in CloudFront. We do the same as the Geo Location Redirects section above. With the Path Pattern, we enter /device.html and remember to select the Cache policy as the device-redirect-cache-policy just created above.\nStep 4: Combine Lambda Function with CloudFront Behavior We do as in the Geo Location Redirects section above, we will combine the Lambda function edge-device-redirect with the CloudFront Behavior just created above.\nStep 5: Set up clients for testing We will need a client to run curl commands. The easy way is to create CloudShell Environments. CloudShell is a shell available in the AWS console and we can run Linux commands from it. Go to CloudShell Console and wait until the terminal is ready to use.\nIf CloudShell does not work, if you are doing this workshop on a Linux/MacOS client, these two operating systems already have curl and you just need to run the command on that client. If you are using Windows, use online curl tools like this one. You can run an EC2 instance or Cloud9 IDE from AWS COnsole to run commands.\nStep 6: Test redirect configuration Go to CloudShell Console.\nIn the test, we will run the curl command to send http requests against our distribution, to do so, we need to copy the Distribution domain name from the CloudFront console where we can find it.\nOnce you\u0026rsquo;ve found the distribution domain name, copy the following command and replace it with our domain name.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/device.html After building the above command from cloudshell, we will see the result as below. \u0026lt; HTTP/1.1 200 OK\r\u0026lt; Content-Type: text/html\r\u0026lt; Content-Length: 106\r\u0026lt; Connection: keep-alive\r\u0026lt; ETag: \u0026#34;73940ca66258e1bd0a623690f24fe324\u0026#34;\r\u0026lt; Accept-Ranges: bytes\r\u0026lt; Server: AmazonS3\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 2f66aa06710fece8ed203ab0ea81eb56.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: IAD89-C3\r\u0026lt; X-Amz-Cf-Id: ChlZowW_za1QF6FVmDX2iTENoknUBJxoxpMNV6S28E37g0khLdnxwg==\r\u0026lt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;non-mobile URI Page\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;non-mobile URI Page\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; The above request shows a regular response. This happens simply because the device we send the request to is not recognized by the Lambda@Edge function as a mobile device and it allows the request to proceed normally.\nPlease run the command below again. curl -v https://d2lagt3tnycm19.cloudfront.net/device.html -A \u0026#34;Mozilla/5.0 (iPhone; CPU iPhone OS 6_1_3 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) CriOS/28.0.1500.12 Mobile/10B329 Safari/8536.25\u0026#34; We will see different responses.\n\u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /mobile.html\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 a4cae74c829bc214e4183c38164a2c0a.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: IAD89-C3\r\u0026lt; X-Amz-Cf-Id: sQ0_5pUMkOAJOBJUiTdDmEKGaq7ExMDotLmPsi-17WouwqcJBu7mNA==\r\u0026lt; The response here is currently HTTP 301, indicating redirect. This happens because the requested User-Agent is identified as a mobile device, our Lambda@Edge catches that and responds with a redirect.\nNow, run the command as in section 4, we will see the difference. \u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /mobile.html\r\u0026lt; X-Cache: Hit from cloudfront\r\u0026lt; Via: 1.1 38ecebcaa39c8742da2b6336935bb446.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: IAD89-C3\r\u0026lt; X-Amz-Cf-Id: 97bOlPobmuIto-LcDA5AbPprf6oXSniK4pq16RRpZSjVPVSb8HUr4Q==\r\u0026lt; Age: 133 The main difference here is that the X-Cache header has the value Hit from cloudfront, meaning this function does not need to be run again because the request has been cached.\nSo we have successfully deployed redirect logic using Lambda@Edge and finished testing. This case can be expanded to be more complex, identifying not only mobile devices but also Android and IOS clients, identifying SmartTVs and Tablets can also be done. Okay. Refer to this document to learn more about all headers location is possible in CloudFront.\n"
},
{
	"uri": "/3-cache/",
	"title": "Use case of Cacheable",
	"tags": [],
	"description": "",
	"content": "Handle Redirects by Lambda@Edge In this section, we will cover cases that can be cached. Ideally, these cases would be handled using Lambda@Edge.\nAs mentioned in the Edge Compute Introduction section, there are many triggers available for Lambda@Edge, cases that will be resolved using Origin facing event triggers.\nLambda@Edge Functions are using Origin facing triggers which will be triggered after the request is evaluated in CloudFront Caching Layers, so if there is a cached response then a response will be returned to the viewer. , saves function invocations. This not only speeds up the response but also helps reduce the cost of our redirects as the Lambda will only be triggered if no response is cached.\nContent Declaring Table in DynamoDB Create Lambda function "
},
{
	"uri": "/4-terminate/",
	"title": "Cleanup",
	"tags": [],
	"description": "",
	"content": "CloudFormation We go to CloudFormation Console We will see a stack named edge-redirect-workshop created from the CloudFormation template. We select that stack and click on the Delete button at the top right. Wait a few minutes and we have successfully deleted CloudFormation and the resources created by it while we started the workshop.\nLambda Function Let\u0026rsquo;s go to Lambda Console We will see all the Lambda Functions created in this workshop. Tick all functions then click on the Actions button at the top right and select Delete. We enter delete in the Confirm box and finally press the Delete button to delete. So we have successfully deleted all the Lambda Functions created in this workshop.\nIf you receive the warning Deleting Lambda@Edge functions and replicas when deleting a Lambda Function, please see [this document](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide /lambda-edge-delete-replicas.html) and follow to delete successfully.\nSo we have successfully completed this workshop. Thank you for your participation.\n"
},
{
	"uri": "/3-cache/3.4-urirew/",
	"title": "URI based Rewrites",
	"tags": [],
	"description": "",
	"content": "This is a technique that does not involve redirecting the client browser to a completely new URL. However, the browser will continue to recognize the URI it requested, but instead of CloudFront retrieving it from the same URI at Original, it will get the content from a different path. For example, let\u0026rsquo;s say a browser has sent a request to resource www.example.com/uri-rewrite.html, but you want to get the content from a different backend path or even a different Origin that the viewer don\u0026rsquo;t know about this. You would then use the Lambda@Edge function or CloudFront function to do the URI rewrite and actually access the origin to request a URI such as www.example.com/rewrite.html\nFor this case, we will use Default Behavior from CloudFront and will not use any specific headers to base our function logic on, so you also do not need to create a new cache policy. However, those can very well be used to create more complex scenarios, where instead of redirecting, we can rewrite the URI on the backend. In our previous examples in this workshop, we could detect the location or device type of the viewer and get a different URI from the backend instead of redirecting the user. The following image depicts the structure of what will be built in this workshop:\nStep 1: Create CloudFront Behavior: Looking back at example URI based Redirects, we create a Behavior with Path Pattern as /uri-rewrite.html and in the section Origin and origin group, we choose myS3Origin.\nStep 2: Create Lambda@Edge function and publish new version In this step, we will do as in the previous part, create a Lambda function with the name edge-uri-rewrite, Runtime is Python 3.9 and deploy it. After that, we need to publish the new version of the Lambda function we just created.\nThe source code of this Lambda function is:\nimport json\rdef lambda_handler(event, context):\r#let\u0026#39;s first extract the URI from the request\rget_uri = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;uri\u0026#39;]\r#let\u0026#39;s check what is the URI and decide if the URI sent to the Origin should be modified\rif (get_uri == \u0026#39;/uri-rewrite.html\u0026#39;):\revent[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;uri\u0026#39;] = \u0026#39;/rewrite.html\u0026#39;\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request\r#if the uri should not be modified then just continue with the request as is\relse:\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Step 3: Combine Lambda Function with CloudFront Behavior We do as in the Geo Location Redirects section above, we will combine the Lambda function edge-uri-rewrite with the CloudFront Behavior we just created above.\nStep 4: Set up clients for testing We will need a client to run curl commands. The easy way is to create CloudShell Environments. CloudShell is a shell available in the AWS console and we can run Linux commands from it. Go to CloudShell Console and wait until the terminal is ready to use.\nIf CloudShell does not work, if you are doing this workshop on a Linux/MacOS client, these two operating systems already have curl and you just need to run the command on that client. If you are using Windows, use online curl tools like this one. You can run an EC2 instance or Cloud9 IDE from AWS COnsole to run commands.\nStep 5: Test redirect configuration Go to CloudShell Console.\nIn the test, we will run the curl command to send http requests against our distribution, to do so, we need to copy the Distribution domain name from the CloudFront console where we can find it.\nOnce you\u0026rsquo;ve found the distribution domain name, copy the following command and replace it with our domain name.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/uri-rewrite.html After building the above command from cloudshell, we will see the result as below. \u0026lt; HTTP/1.1 200 OK\r\u0026lt; Content-Type: text/html\r\u0026lt; Content-Length: 92\r\u0026lt; Connection: keep-alive\r\u0026lt; ETag: \u0026#34;a1764624bd34afb8e52157f114ef6db1\u0026#34;\r\u0026lt; Accept-Ranges: bytes\r\u0026lt; Server: AmazonS3\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 3cf1bfec064e2e01f071e8051a22d830.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: ATL56-C1\r\u0026lt; X-Amz-Cf-Id: HeF7XzxKoVyNxUKAAnP0t8bCzpwbN-pyex3mRMbqcH-mQOT5V3yjAw==\r\u0026lt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;Rewrite Page\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;Rewrite Page\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; The above request shows that the direct response to our request is HTTP 200 OK, meaning this is not a redirect, instead content has been provided, however in this page you can see the generated HTML saying This is rewrite content instead of main content.\nSo we have successfully deployed the URI rewrite case. This scenario can be extended to handle more complex logic as well as even retrieve content from different origins if required. This case can also be done using CloudFront functions if our case requires all requests to be evaluated and rewritten.\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]